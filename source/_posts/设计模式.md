---
title: 设计模式 
date: 2020-05-17 17:19:28 
tags: 
 - blog
 - 设计模式
categories: 
  - 编程
---

### 设计模式

> 抽象工厂模式 （Abstract Factory）

多个类继承自同一个 `Abstract Class`的`Factory`，实现相同的借口，不关心客户如何创建这些对象。

> 静态工厂模式（Static Factory）

与抽奖工厂模式类似，用于创建一系列相关或者互相依赖的对象，一般只用一个静态方法来创建所有类型对象，此方法通常命名为`factory`和`build`。

> 简单工厂模式（Simple Factory）

和静态工厂模式最大的区别是它不是静态的。

> 工厂方法模式 （Factory Method）

对于简单工厂模式的优点是，可以将其子类用不同的方法来创建对象。

> 单例模式（Singleton）

在应用程序调用时只能获得一个实力对象。

将自身赋值在自己静态属性中，私有化构造方法，克隆方法，反序列化方法，保持单例防止创建多个实例。

> 多例模式（Multiton）

多例模式算是单例模式的一种推广，保持多例自己创建，管理，并向外界提供自己的实例。

> 对象池模式（Pool)

提前初始化好一组对象，当客户需要使用时向对象池请求一个对象，当使用完毕以后将对象返回给对象池而不是销毁。



> 适配器模式（Adapter）

将一个类的借口转换成可应用的兼容接口，使原本由于接口不兼容而不能一起工作的类可以一起工作。

> 组合模式（ComPosite)

一组对象与该对象的单个实例处理方式一致。

> 依赖注入模式（Dependency Injection）

用松耦合的方式来实现更好的可测试、可维护、可扩展的代码。

> 门面模式（Facade)

通过门面直接调用子系统。

> 注册模式（Registry）

目的是存储在应用程序经常使用的对象实例。

> 责任链模式（Chain Of Responsibilities）

建立一个对象链来指定执行顺序调用，如果前面的对象无法处理命令，就交由下一个对象去处理。

> 观察者模式（Observer）

当状态发生改变时，所有依赖于它的对象都将得到通知并被自动更新。





